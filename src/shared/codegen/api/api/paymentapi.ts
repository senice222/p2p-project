/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ActualPaymentDTO } from '../models';
// @ts-ignore
import type { Amount } from '../models';
// @ts-ignore
import type { AuthError } from '../models';
// @ts-ignore
import type { ErrorObjWithNearest } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { OrderDataOut } from '../models';
// @ts-ignore
import type { RatingInDto } from '../models';
// @ts-ignore
import type { SetStatusInDTO } from '../models';
// @ts-ignore
import type { SetStatusOutDTO } from '../models';
// @ts-ignore
import type { SimpleErrorObj } from '../models';
// @ts-ignore
import type { StatusErrorObj } from '../models';
/**
 * PAYMENTAPPApi - axios parameter creator
 * @export
 */
export const PAYMENTAPPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * :param request: :return: Данные платежа или null  Получить активный платеж в статусе \"created\" или \"wait_document\", если он есть
         * @summary Check Active Payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActivePaymentMarketPaymentAppCheckActivePaymentGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/market/payment_app/check_active_payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :param params: amount: decimal, payment_method_id: int, lolz_username: str :param request: :return:  **409**  `payment_type` -  LOLZ_DEPOSIT_APP - Платеж из этого приложения. отображаем его тут.  BOT, CALCULATOR - Платеж из бота или калькулятора.  Уточняем что хочет сделать пользователь и пинаем в market/mini_app/calc_order/active_payment.  Если платеж **cancellable** - можем сразу закрыть   ### Статусы платежа:  0 - created; 1 - wait_document; 2 - wait_confirm; 3 - confirmed; 4 - cancelled; 5 - expired; 6 - declined;   **400**  `too_many_active_payments` - У пользователя слишком много платежей в статусе \"ожидает проверки\"  `value_error` - Ошибка в параметрах запроса  **404**  `order_not_exist` - Ордер закрыт / удален / не существует / изменилась сумма  `order_not_found_error` - Нет подходящих ордеров
         * @summary Create New Payment
         * @param {Amount} amount 
         * @param {number} paymentMethodId 
         * @param {number} lolzUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPaymentMarketPaymentAppCreatePaymentGet: async (amount: Amount, paymentMethodId: number, lolzUserId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('createNewPaymentMarketPaymentAppCreatePaymentGet', 'amount', amount)
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('createNewPaymentMarketPaymentAppCreatePaymentGet', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'lolzUserId' is not null or undefined
            assertParamExists('createNewPaymentMarketPaymentAppCreatePaymentGet', 'lolzUserId', lolzUserId)
            const localVarPath = `/market/payment_app/create_payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)

            if (amount !== undefined) {
                for (const [key, value] of Object.entries(amount)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['payment_method_id'] = paymentMethodId;
            }

            if (lolzUserId !== undefined) {
                localVarQueryParameter['lolz_user_id'] = lolzUserId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :param username: :param request: :return:  Этот запрос проксируется из https://prod-api.zelenka.guru/users/find  Возвращает оригинальный ответ внешнего API со всеми заголовками и телом.
         * @summary Find Lzt User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLztUserMarketPaymentAppFindLztUserUsernameGet: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findLztUserMarketPaymentAppFindLztUserUsernameGet', 'username', username)
            const localVarPath = `/market/payment_app/find_lzt_user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Payment Method Types
         * @param {Amount} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet: async (amount: Amount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet', 'amount', amount)
            const localVarPath = `/market/payment_app/payment_method_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)

            if (amount !== undefined) {
                for (const [key, value] of Object.entries(amount)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Payment Methods
         * @param {Amount} amount 
         * @param {string} paymentMethodType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsMarketPaymentAppPaymentMethodsGet: async (amount: Amount, paymentMethodType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('paymentMethodsMarketPaymentAppPaymentMethodsGet', 'amount', amount)
            // verify required parameter 'paymentMethodType' is not null or undefined
            assertParamExists('paymentMethodsMarketPaymentAppPaymentMethodsGet', 'paymentMethodType', paymentMethodType)
            const localVarPath = `/market/payment_app/payment_methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)

            if (amount !== undefined) {
                for (const [key, value] of Object.entries(amount)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (paymentMethodType !== undefined) {
                localVarQueryParameter['payment_method_type'] = paymentMethodType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :param request: :param body: :return:  Изменить статус платежа.  статус **\"created\"** может быть изменен на **\"wait_document\"** (true) или **\"cancelled\"** (false)  статус **\"wait_document\"** может быть изменен на **\"cancelled\"** (false)  Во всех остальных случаях - 404
         * @summary Set Payment Status
         * @param {SetStatusInDTO} setStatusInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPaymentStatusMarketPaymentAppSetPaymentStatusPost: async (setStatusInDTO: SetStatusInDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setStatusInDTO' is not null or undefined
            assertParamExists('setPaymentStatusMarketPaymentAppSetPaymentStatusPost', 'setStatusInDTO', setStatusInDTO)
            const localVarPath = `/market/payment_app/set_payment_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStatusInDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :param request: :param body: :return:  Ставит оценку продавцу. Платеж не будет найден, если он уже оценен.  Если rating=False, поле info обязательно.  Если rating=True, поле info не должно присутствовать.
         * @summary Set Rating
         * @param {RatingInDto} ratingInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRatingMarketPaymentAppSetRatingPost: async (ratingInDto: RatingInDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ratingInDto' is not null or undefined
            assertParamExists('setRatingMarketPaymentAppSetRatingPost', 'ratingInDto', ratingInDto)
            const localVarPath = `/market/payment_app/set_rating`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ratingInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :param payment_id: :param file: :param request: :return:  Платеж должен иметь статус **\"wait_document\"**.
         * @summary Upload File
         * @param {any} paymentId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileMarketPaymentAppUploadFilePost: async (paymentId: any, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('uploadFileMarketPaymentAppUploadFilePost', 'paymentId', paymentId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadFileMarketPaymentAppUploadFilePost', 'file', file)
            const localVarPath = `/market/payment_app/upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication APIKeyHeader required
            await setApiKeyToObject(localVarHeaderParameter, "InitData", configuration)

            if (paymentId !== undefined) {
                for (const [key, value] of Object.entries(paymentId)) {
                    localVarQueryParameter[key] = value;
                }
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PAYMENTAPPApi - functional programming interface
 * @export
 */
export const PAYMENTAPPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PAYMENTAPPApiAxiosParamCreator(configuration)
    return {
        /**
         * :param request: :return: Данные платежа или null  Получить активный платеж в статусе \"created\" или \"wait_document\", если он есть
         * @summary Check Active Payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActualPaymentDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.checkActivePaymentMarketPaymentAppCheckActivePaymentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * :param params: amount: decimal, payment_method_id: int, lolz_username: str :param request: :return:  **409**  `payment_type` -  LOLZ_DEPOSIT_APP - Платеж из этого приложения. отображаем его тут.  BOT, CALCULATOR - Платеж из бота или калькулятора.  Уточняем что хочет сделать пользователь и пинаем в market/mini_app/calc_order/active_payment.  Если платеж **cancellable** - можем сразу закрыть   ### Статусы платежа:  0 - created; 1 - wait_document; 2 - wait_confirm; 3 - confirmed; 4 - cancelled; 5 - expired; 6 - declined;   **400**  `too_many_active_payments` - У пользователя слишком много платежей в статусе \"ожидает проверки\"  `value_error` - Ошибка в параметрах запроса  **404**  `order_not_exist` - Ордер закрыт / удален / не существует / изменилась сумма  `order_not_found_error` - Нет подходящих ордеров
         * @summary Create New Payment
         * @param {Amount} amount 
         * @param {number} paymentMethodId 
         * @param {number} lolzUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewPaymentMarketPaymentAppCreatePaymentGet(amount: Amount, paymentMethodId: number, lolzUserId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewPaymentMarketPaymentAppCreatePaymentGet(amount, paymentMethodId, lolzUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.createNewPaymentMarketPaymentAppCreatePaymentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * :param username: :param request: :return:  Этот запрос проксируется из https://prod-api.zelenka.guru/users/find  Возвращает оригинальный ответ внешнего API со всеми заголовками и телом.
         * @summary Find Lzt User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLztUserMarketPaymentAppFindLztUserUsernameGet(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLztUserMarketPaymentAppFindLztUserUsernameGet(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.findLztUserMarketPaymentAppFindLztUserUsernameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Payment Method Types
         * @param {Amount} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(amount: Amount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDataOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Payment Methods
         * @param {Amount} amount 
         * @param {string} paymentMethodType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentMethodsMarketPaymentAppPaymentMethodsGet(amount: Amount, paymentMethodType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDataOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentMethodsMarketPaymentAppPaymentMethodsGet(amount, paymentMethodType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.paymentMethodsMarketPaymentAppPaymentMethodsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * :param request: :param body: :return:  Изменить статус платежа.  статус **\"created\"** может быть изменен на **\"wait_document\"** (true) или **\"cancelled\"** (false)  статус **\"wait_document\"** может быть изменен на **\"cancelled\"** (false)  Во всех остальных случаях - 404
         * @summary Set Payment Status
         * @param {SetStatusInDTO} setStatusInDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPaymentStatusMarketPaymentAppSetPaymentStatusPost(setStatusInDTO: SetStatusInDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetStatusOutDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPaymentStatusMarketPaymentAppSetPaymentStatusPost(setStatusInDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.setPaymentStatusMarketPaymentAppSetPaymentStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * :param request: :param body: :return:  Ставит оценку продавцу. Платеж не будет найден, если он уже оценен.  Если rating=False, поле info обязательно.  Если rating=True, поле info не должно присутствовать.
         * @summary Set Rating
         * @param {RatingInDto} ratingInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRatingMarketPaymentAppSetRatingPost(ratingInDto: RatingInDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetStatusOutDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRatingMarketPaymentAppSetRatingPost(ratingInDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.setRatingMarketPaymentAppSetRatingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * :param payment_id: :param file: :param request: :return:  Платеж должен иметь статус **\"wait_document\"**.
         * @summary Upload File
         * @param {any} paymentId 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileMarketPaymentAppUploadFilePost(paymentId: any, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetStatusOutDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileMarketPaymentAppUploadFilePost(paymentId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PAYMENTAPPApi.uploadFileMarketPaymentAppUploadFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PAYMENTAPPApi - factory interface
 * @export
 */
export const PAYMENTAPPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PAYMENTAPPApiFp(configuration)
    return {
        /**
         * :param request: :return: Данные платежа или null  Получить активный платеж в статусе \"created\" или \"wait_document\", если он есть
         * @summary Check Active Payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ActualPaymentDTO>> {
            return localVarFp.checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * :param params: amount: decimal, payment_method_id: int, lolz_username: str :param request: :return:  **409**  `payment_type` -  LOLZ_DEPOSIT_APP - Платеж из этого приложения. отображаем его тут.  BOT, CALCULATOR - Платеж из бота или калькулятора.  Уточняем что хочет сделать пользователь и пинаем в market/mini_app/calc_order/active_payment.  Если платеж **cancellable** - можем сразу закрыть   ### Статусы платежа:  0 - created; 1 - wait_document; 2 - wait_confirm; 3 - confirmed; 4 - cancelled; 5 - expired; 6 - declined;   **400**  `too_many_active_payments` - У пользователя слишком много платежей в статусе \"ожидает проверки\"  `value_error` - Ошибка в параметрах запроса  **404**  `order_not_exist` - Ордер закрыт / удален / не существует / изменилась сумма  `order_not_found_error` - Нет подходящих ордеров
         * @summary Create New Payment
         * @param {PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPaymentMarketPaymentAppCreatePaymentGet(requestParameters: PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderDataOut> {
            return localVarFp.createNewPaymentMarketPaymentAppCreatePaymentGet(requestParameters.amount, requestParameters.paymentMethodId, requestParameters.lolzUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * :param username: :param request: :return:  Этот запрос проксируется из https://prod-api.zelenka.guru/users/find  Возвращает оригинальный ответ внешнего API со всеми заголовками и телом.
         * @summary Find Lzt User
         * @param {PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLztUserMarketPaymentAppFindLztUserUsernameGet(requestParameters: PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderDataOut> {
            return localVarFp.findLztUserMarketPaymentAppFindLztUserUsernameGet(requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Payment Method Types
         * @param {PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(requestParameters: PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDataOut>> {
            return localVarFp.paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(requestParameters.amount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Payment Methods
         * @param {PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentMethodsMarketPaymentAppPaymentMethodsGet(requestParameters: PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderDataOut> {
            return localVarFp.paymentMethodsMarketPaymentAppPaymentMethodsGet(requestParameters.amount, requestParameters.paymentMethodType, options).then((request) => request(axios, basePath));
        },
        /**
         * :param request: :param body: :return:  Изменить статус платежа.  статус **\"created\"** может быть изменен на **\"wait_document\"** (true) или **\"cancelled\"** (false)  статус **\"wait_document\"** может быть изменен на **\"cancelled\"** (false)  Во всех остальных случаях - 404
         * @summary Set Payment Status
         * @param {PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPaymentStatusMarketPaymentAppSetPaymentStatusPost(requestParameters: PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetStatusOutDTO> {
            return localVarFp.setPaymentStatusMarketPaymentAppSetPaymentStatusPost(requestParameters.setStatusInDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * :param request: :param body: :return:  Ставит оценку продавцу. Платеж не будет найден, если он уже оценен.  Если rating=False, поле info обязательно.  Если rating=True, поле info не должно присутствовать.
         * @summary Set Rating
         * @param {PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRatingMarketPaymentAppSetRatingPost(requestParameters: PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetStatusOutDTO> {
            return localVarFp.setRatingMarketPaymentAppSetRatingPost(requestParameters.ratingInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * :param payment_id: :param file: :param request: :return:  Платеж должен иметь статус **\"wait_document\"**.
         * @summary Upload File
         * @param {PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileMarketPaymentAppUploadFilePost(requestParameters: PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<SetStatusOutDTO> {
            return localVarFp.uploadFileMarketPaymentAppUploadFilePost(requestParameters.paymentId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewPaymentMarketPaymentAppCreatePaymentGet operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest
 */
export interface PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest {
    /**
     * 
     * @type {Amount}
     * @memberof PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGet
     */
    readonly amount: Amount

    /**
     * 
     * @type {number}
     * @memberof PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGet
     */
    readonly paymentMethodId: number

    /**
     * 
     * @type {number}
     * @memberof PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGet
     */
    readonly lolzUserId: number
}

/**
 * Request parameters for findLztUserMarketPaymentAppFindLztUserUsernameGet operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest
 */
export interface PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGet
     */
    readonly username: string
}

/**
 * Request parameters for paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest
 */
export interface PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest {
    /**
     * 
     * @type {Amount}
     * @memberof PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGet
     */
    readonly amount: Amount
}

/**
 * Request parameters for paymentMethodsMarketPaymentAppPaymentMethodsGet operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest
 */
export interface PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest {
    /**
     * 
     * @type {Amount}
     * @memberof PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGet
     */
    readonly amount: Amount

    /**
     * 
     * @type {string}
     * @memberof PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGet
     */
    readonly paymentMethodType: string
}

/**
 * Request parameters for setPaymentStatusMarketPaymentAppSetPaymentStatusPost operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest
 */
export interface PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest {
    /**
     * 
     * @type {SetStatusInDTO}
     * @memberof PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPost
     */
    readonly setStatusInDTO: SetStatusInDTO
}

/**
 * Request parameters for setRatingMarketPaymentAppSetRatingPost operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest
 */
export interface PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest {
    /**
     * 
     * @type {RatingInDto}
     * @memberof PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPost
     */
    readonly ratingInDto: RatingInDto
}

/**
 * Request parameters for uploadFileMarketPaymentAppUploadFilePost operation in PAYMENTAPPApi.
 * @export
 * @interface PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest
 */
export interface PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest {
    /**
     * 
     * @type {any}
     * @memberof PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePost
     */
    readonly paymentId: any

    /**
     * 
     * @type {File}
     * @memberof PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePost
     */
    readonly file: File
}

/**
 * PAYMENTAPPApi - object-oriented interface
 * @export
 * @class PAYMENTAPPApi
 * @extends {BaseAPI}
 */
export class PAYMENTAPPApi extends BaseAPI {
    /**
     * :param request: :return: Данные платежа или null  Получить активный платеж в статусе \"created\" или \"wait_document\", если он есть
     * @summary Check Active Payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).checkActivePaymentMarketPaymentAppCheckActivePaymentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :param params: amount: decimal, payment_method_id: int, lolz_username: str :param request: :return:  **409**  `payment_type` -  LOLZ_DEPOSIT_APP - Платеж из этого приложения. отображаем его тут.  BOT, CALCULATOR - Платеж из бота или калькулятора.  Уточняем что хочет сделать пользователь и пинаем в market/mini_app/calc_order/active_payment.  Если платеж **cancellable** - можем сразу закрыть   ### Статусы платежа:  0 - created; 1 - wait_document; 2 - wait_confirm; 3 - confirmed; 4 - cancelled; 5 - expired; 6 - declined;   **400**  `too_many_active_payments` - У пользователя слишком много платежей в статусе \"ожидает проверки\"  `value_error` - Ошибка в параметрах запроса  **404**  `order_not_exist` - Ордер закрыт / удален / не существует / изменилась сумма  `order_not_found_error` - Нет подходящих ордеров
     * @summary Create New Payment
     * @param {PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public createNewPaymentMarketPaymentAppCreatePaymentGet(requestParameters: PAYMENTAPPApiCreateNewPaymentMarketPaymentAppCreatePaymentGetRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).createNewPaymentMarketPaymentAppCreatePaymentGet(requestParameters.amount, requestParameters.paymentMethodId, requestParameters.lolzUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :param username: :param request: :return:  Этот запрос проксируется из https://prod-api.zelenka.guru/users/find  Возвращает оригинальный ответ внешнего API со всеми заголовками и телом.
     * @summary Find Lzt User
     * @param {PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public findLztUserMarketPaymentAppFindLztUserUsernameGet(requestParameters: PAYMENTAPPApiFindLztUserMarketPaymentAppFindLztUserUsernameGetRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).findLztUserMarketPaymentAppFindLztUserUsernameGet(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Payment Method Types
     * @param {PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(requestParameters: PAYMENTAPPApiPaymentMethodTypesMarketPaymentAppPaymentMethodTypesGetRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).paymentMethodTypesMarketPaymentAppPaymentMethodTypesGet(requestParameters.amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Payment Methods
     * @param {PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public paymentMethodsMarketPaymentAppPaymentMethodsGet(requestParameters: PAYMENTAPPApiPaymentMethodsMarketPaymentAppPaymentMethodsGetRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).paymentMethodsMarketPaymentAppPaymentMethodsGet(requestParameters.amount, requestParameters.paymentMethodType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :param request: :param body: :return:  Изменить статус платежа.  статус **\"created\"** может быть изменен на **\"wait_document\"** (true) или **\"cancelled\"** (false)  статус **\"wait_document\"** может быть изменен на **\"cancelled\"** (false)  Во всех остальных случаях - 404
     * @summary Set Payment Status
     * @param {PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public setPaymentStatusMarketPaymentAppSetPaymentStatusPost(requestParameters: PAYMENTAPPApiSetPaymentStatusMarketPaymentAppSetPaymentStatusPostRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).setPaymentStatusMarketPaymentAppSetPaymentStatusPost(requestParameters.setStatusInDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :param request: :param body: :return:  Ставит оценку продавцу. Платеж не будет найден, если он уже оценен.  Если rating=False, поле info обязательно.  Если rating=True, поле info не должно присутствовать.
     * @summary Set Rating
     * @param {PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public setRatingMarketPaymentAppSetRatingPost(requestParameters: PAYMENTAPPApiSetRatingMarketPaymentAppSetRatingPostRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).setRatingMarketPaymentAppSetRatingPost(requestParameters.ratingInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * :param payment_id: :param file: :param request: :return:  Платеж должен иметь статус **\"wait_document\"**.
     * @summary Upload File
     * @param {PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PAYMENTAPPApi
     */
    public uploadFileMarketPaymentAppUploadFilePost(requestParameters: PAYMENTAPPApiUploadFileMarketPaymentAppUploadFilePostRequest, options?: RawAxiosRequestConfig) {
        return PAYMENTAPPApiFp(this.configuration).uploadFileMarketPaymentAppUploadFilePost(requestParameters.paymentId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}

